// @generated
/// Params defines the parameters for the module.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Params {
    #[prost(string, repeated, tag = "1")]
    pub allowed_dkg_participants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub dkg_timeout_duration:
        ::core::option::Option<::tendermint_proto::google::protobuf::Duration>,
}
impl ::prost::Name for Params {
    const NAME: &'static str = "Params";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// DKG Request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgRequest {
    /// request id
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// initiator module
    #[prost(string, tag = "2")]
    pub module: ::prost::alloc::string::String,
    /// dkg type
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    /// dkg intent
    #[prost(int32, tag = "4")]
    pub intent: i32,
    /// participant set
    #[prost(string, repeated, tag = "5")]
    pub participants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// threshold required to perform DKG
    #[prost(uint32, tag = "6")]
    pub threshold: u32,
    /// batch size of keys to be generated
    #[prost(uint32, tag = "7")]
    pub batch_size: u32,
    /// expiration time
    #[prost(message, optional, tag = "8")]
    pub expiration_time: ::core::option::Option<::tendermint_proto::google::protobuf::Timestamp>,
    /// status
    #[prost(enumeration = "DkgStatus", tag = "9")]
    pub status: i32,
}
impl ::prost::Name for DkgRequest {
    const NAME: &'static str = "DKGRequest";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// DKG Completion
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgCompletion {
    /// request id
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// sender
    #[prost(string, tag = "2")]
    pub sender: ::prost::alloc::string::String,
    /// public keys generated by DKG
    #[prost(string, repeated, tag = "3")]
    pub pub_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// participant consensus pub key
    #[prost(string, tag = "4")]
    pub consensus_pubkey: ::prost::alloc::string::String,
    /// hex encoded participant signature
    #[prost(string, tag = "5")]
    pub signature: ::prost::alloc::string::String,
}
impl ::prost::Name for DkgCompletion {
    const NAME: &'static str = "DKGCompletion";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// Signing Options
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SigningOptions {
    /// optional public nonce, i.e. commitment
    #[prost(string, tag = "1")]
    pub nonce: ::prost::alloc::string::String,
    /// optional adaptor point
    #[prost(string, tag = "2")]
    pub adaptor_point: ::prost::alloc::string::String,
}
impl ::prost::Name for SigningOptions {
    const NAME: &'static str = "SigningOptions";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// Signing Request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SigningRequest {
    /// request id
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// initiator module
    #[prost(string, tag = "2")]
    pub module: ::prost::alloc::string::String,
    /// module specific id
    #[prost(string, tag = "3")]
    pub scoped_id: ::prost::alloc::string::String,
    /// signing type
    #[prost(enumeration = "SigningType", tag = "4")]
    pub r#type: i32,
    /// signing intent
    #[prost(int32, tag = "5")]
    pub intent: i32,
    /// signing pub key
    #[prost(string, tag = "6")]
    pub pub_key: ::prost::alloc::string::String,
    /// hashes to be signed
    #[prost(string, repeated, tag = "7")]
    pub sig_hashes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// signing options
    #[prost(message, optional, tag = "8")]
    pub options: ::core::option::Option<SigningOptions>,
    /// creation time
    #[prost(message, optional, tag = "9")]
    pub creation_time: ::core::option::Option<::tendermint_proto::google::protobuf::Timestamp>,
    /// status
    #[prost(enumeration = "SigningStatus", tag = "10")]
    pub status: i32,
}
impl ::prost::Name for SigningRequest {
    const NAME: &'static str = "SigningRequest";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// Refreshing Request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshingRequest {
    /// request id
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// request id of the DKG corresponding to the key shares to be refreshed
    #[prost(uint64, tag = "2")]
    pub dkg_id: u64,
    /// removed participant set
    #[prost(string, repeated, tag = "3")]
    pub removed_participants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// new threshold
    #[prost(uint32, tag = "4")]
    pub threshold: u32,
    /// expiration time
    #[prost(message, optional, tag = "5")]
    pub expiration_time: ::core::option::Option<::tendermint_proto::google::protobuf::Timestamp>,
    /// status
    #[prost(enumeration = "RefreshingStatus", tag = "6")]
    pub status: i32,
}
impl ::prost::Name for RefreshingRequest {
    const NAME: &'static str = "RefreshingRequest";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// Refreshing Completion
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshingCompletion {
    /// request id
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// sender
    #[prost(string, tag = "2")]
    pub sender: ::prost::alloc::string::String,
    /// participant consensus pub key
    #[prost(string, tag = "3")]
    pub consensus_pubkey: ::prost::alloc::string::String,
    /// hex encoded participant signature
    #[prost(string, tag = "4")]
    pub signature: ::prost::alloc::string::String,
}
impl ::prost::Name for RefreshingCompletion {
    const NAME: &'static str = "RefreshingCompletion";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// DKG Status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DkgStatus {
    /// DKG_STATUS_UNSPECIFIED defines the unknown DKG request status
    Unspecified = 0,
    /// DKG_STATUS_PENDING defines the status of the DKG request which is pending
    Pending = 1,
    /// DKG_STATUS_COMPLETED defines the status of the DKG request which is completed
    Completed = 2,
    /// DKG_STATUS_FAILED defines the status of the DKG request which failed
    Failed = 3,
    /// DKG_STATUS_TIMEDOUT defines the status of the DKG request which timed out
    Timedout = 4,
}
impl DkgStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DkgStatus::Unspecified => "DKG_STATUS_UNSPECIFIED",
            DkgStatus::Pending => "DKG_STATUS_PENDING",
            DkgStatus::Completed => "DKG_STATUS_COMPLETED",
            DkgStatus::Failed => "DKG_STATUS_FAILED",
            DkgStatus::Timedout => "DKG_STATUS_TIMEDOUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DKG_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "DKG_STATUS_PENDING" => Some(Self::Pending),
            "DKG_STATUS_COMPLETED" => Some(Self::Completed),
            "DKG_STATUS_FAILED" => Some(Self::Failed),
            "DKG_STATUS_TIMEDOUT" => Some(Self::Timedout),
            _ => None,
        }
    }
}
/// Signing Status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SigningStatus {
    /// SIGNING_STATUS_UNSPECIFIED defines the unknown signing status
    Unspecified = 0,
    /// SIGNING_STATUS_PENDING defines the status of the signing request which is pending
    Pending = 1,
    /// SIGNING_STATUS_SIGNED defines the status of the signing request which is signed
    Signed = 2,
    /// SIGNING_STATUS_FAILED defines the status of the signing request which failed due to unexpected reasons
    Failed = 3,
}
impl SigningStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SigningStatus::Unspecified => "SIGNING_STATUS_UNSPECIFIED",
            SigningStatus::Pending => "SIGNING_STATUS_PENDING",
            SigningStatus::Signed => "SIGNING_STATUS_SIGNED",
            SigningStatus::Failed => "SIGNING_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNING_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "SIGNING_STATUS_PENDING" => Some(Self::Pending),
            "SIGNING_STATUS_SIGNED" => Some(Self::Signed),
            "SIGNING_STATUS_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
/// Signing Type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SigningType {
    /// SIGNING_TYPE_SCHNORR defines the common schnorr signing
    Schnorr = 0,
    /// SIGNING_TYPE_SCHNORR_WITH_COMMITMENT defines the schnorr signing with commitment
    SchnorrWithCommitment = 1,
    /// SIGNING_TYPE_SCHNORR_ADAPTOR defines the schnorr adaptor signing
    SchnorrAdaptor = 2,
}
impl SigningType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SigningType::Schnorr => "SIGNING_TYPE_SCHNORR",
            SigningType::SchnorrWithCommitment => "SIGNING_TYPE_SCHNORR_WITH_COMMITMENT",
            SigningType::SchnorrAdaptor => "SIGNING_TYPE_SCHNORR_ADAPTOR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNING_TYPE_SCHNORR" => Some(Self::Schnorr),
            "SIGNING_TYPE_SCHNORR_WITH_COMMITMENT" => Some(Self::SchnorrWithCommitment),
            "SIGNING_TYPE_SCHNORR_ADAPTOR" => Some(Self::SchnorrAdaptor),
            _ => None,
        }
    }
}
/// Refreshing Status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RefreshingStatus {
    /// REFRESHING_STATUS_UNSPECIFIED defines the unknown refreshing status
    Unspecified = 0,
    /// REFRESHING_STATUS_PENDING defines the status of the refreshing request which is pending
    Pending = 1,
    /// REFRESHING_STATUS_COMPLETED defines the status of the refreshing request which is completed
    Completed = 2,
    /// REFRESHING_STATUS_TIMEDOUT defines the status of the refreshing request which timed out
    Timedout = 3,
}
impl RefreshingStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RefreshingStatus::Unspecified => "REFRESHING_STATUS_UNSPECIFIED",
            RefreshingStatus::Pending => "REFRESHING_STATUS_PENDING",
            RefreshingStatus::Completed => "REFRESHING_STATUS_COMPLETED",
            RefreshingStatus::Timedout => "REFRESHING_STATUS_TIMEDOUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REFRESHING_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "REFRESHING_STATUS_PENDING" => Some(Self::Pending),
            "REFRESHING_STATUS_COMPLETED" => Some(Self::Completed),
            "REFRESHING_STATUS_TIMEDOUT" => Some(Self::Timedout),
            _ => None,
        }
    }
}
/// GenesisState defines the module's genesis state.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
    #[prost(message, repeated, tag = "2")]
    pub dkg_requests: ::prost::alloc::vec::Vec<DkgRequest>,
    #[prost(message, repeated, tag = "3")]
    pub signing_requests: ::prost::alloc::vec::Vec<SigningRequest>,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDkgRequestRequest {
    #[prost(uint64, tag = "1")]
    pub id: u64,
}
impl ::prost::Name for QueryDkgRequestRequest {
    const NAME: &'static str = "QueryDKGRequestRequest";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDkgRequestResponse {
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<DkgRequest>,
}
impl ::prost::Name for QueryDkgRequestResponse {
    const NAME: &'static str = "QueryDKGRequestResponse";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDkgRequestsRequest {
    #[prost(string, tag = "1")]
    pub module: ::prost::alloc::string::String,
    #[prost(enumeration = "DkgStatus", tag = "2")]
    pub status: i32,
    #[prost(message, optional, tag = "3")]
    pub pagination: ::core::option::Option<super::super::cosmos::base::query::v1beta1::PageRequest>,
}
impl ::prost::Name for QueryDkgRequestsRequest {
    const NAME: &'static str = "QueryDKGRequestsRequest";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDkgRequestsResponse {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<DkgRequest>,
    #[prost(message, optional, tag = "2")]
    pub pagination:
        ::core::option::Option<super::super::cosmos::base::query::v1beta1::PageResponse>,
}
impl ::prost::Name for QueryDkgRequestsResponse {
    const NAME: &'static str = "QueryDKGRequestsResponse";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDkgCompletionsRequest {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<super::super::cosmos::base::query::v1beta1::PageRequest>,
}
impl ::prost::Name for QueryDkgCompletionsRequest {
    const NAME: &'static str = "QueryDKGCompletionsRequest";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDkgCompletionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub completions: ::prost::alloc::vec::Vec<DkgCompletion>,
    #[prost(message, optional, tag = "2")]
    pub pagination:
        ::core::option::Option<super::super::cosmos::base::query::v1beta1::PageResponse>,
}
impl ::prost::Name for QueryDkgCompletionsResponse {
    const NAME: &'static str = "QueryDKGCompletionsResponse";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySigningRequestRequest {
    #[prost(uint64, tag = "1")]
    pub id: u64,
}
impl ::prost::Name for QuerySigningRequestRequest {
    const NAME: &'static str = "QuerySigningRequestRequest";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySigningRequestResponse {
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<SigningRequest>,
}
impl ::prost::Name for QuerySigningRequestResponse {
    const NAME: &'static str = "QuerySigningRequestResponse";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySigningRequestsRequest {
    #[prost(string, tag = "1")]
    pub module: ::prost::alloc::string::String,
    #[prost(enumeration = "SigningStatus", tag = "2")]
    pub status: i32,
    #[prost(message, optional, tag = "3")]
    pub pagination: ::core::option::Option<super::super::cosmos::base::query::v1beta1::PageRequest>,
}
impl ::prost::Name for QuerySigningRequestsRequest {
    const NAME: &'static str = "QuerySigningRequestsRequest";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySigningRequestsResponse {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<SigningRequest>,
    #[prost(message, optional, tag = "2")]
    pub pagination:
        ::core::option::Option<super::super::cosmos::base::query::v1beta1::PageResponse>,
}
impl ::prost::Name for QuerySigningRequestsResponse {
    const NAME: &'static str = "QuerySigningRequestsResponse";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRefreshingRequestRequest {
    #[prost(uint64, tag = "1")]
    pub id: u64,
}
impl ::prost::Name for QueryRefreshingRequestRequest {
    const NAME: &'static str = "QueryRefreshingRequestRequest";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRefreshingRequestResponse {
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<RefreshingRequest>,
}
impl ::prost::Name for QueryRefreshingRequestResponse {
    const NAME: &'static str = "QueryRefreshingRequestResponse";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRefreshingRequestsRequest {
    #[prost(enumeration = "RefreshingStatus", tag = "1")]
    pub status: i32,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<super::super::cosmos::base::query::v1beta1::PageRequest>,
}
impl ::prost::Name for QueryRefreshingRequestsRequest {
    const NAME: &'static str = "QueryRefreshingRequestsRequest";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRefreshingRequestsResponse {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<RefreshingRequest>,
    #[prost(message, optional, tag = "2")]
    pub pagination:
        ::core::option::Option<super::super::cosmos::base::query::v1beta1::PageResponse>,
}
impl ::prost::Name for QueryRefreshingRequestsResponse {
    const NAME: &'static str = "QueryRefreshingRequestsResponse";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRefreshingCompletionsRequest {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<super::super::cosmos::base::query::v1beta1::PageRequest>,
}
impl ::prost::Name for QueryRefreshingCompletionsRequest {
    const NAME: &'static str = "QueryRefreshingCompletionsRequest";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRefreshingCompletionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub completions: ::prost::alloc::vec::Vec<RefreshingCompletion>,
    #[prost(message, optional, tag = "2")]
    pub pagination:
        ::core::option::Option<super::super::cosmos::base::query::v1beta1::PageResponse>,
}
impl ::prost::Name for QueryRefreshingCompletionsResponse {
    const NAME: &'static str = "QueryRefreshingCompletionsResponse";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// QueryParamsRequest is request type for the Query/Params RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryParamsRequest {}
impl ::prost::Name for QueryParamsRequest {
    const NAME: &'static str = "QueryParamsRequest";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// QueryParamsResponse is response type for the Query/Params RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryParamsResponse {
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for QueryParamsResponse {
    const NAME: &'static str = "QueryParamsResponse";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// MsgCompleteDKG is the Msg/CompleteDKG request type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCompleteDkg {
    /// sender
    #[prost(string, tag = "1")]
    pub sender: ::prost::alloc::string::String,
    /// DKG request id
    #[prost(uint64, tag = "2")]
    pub id: u64,
    /// public keys generated by DKG
    #[prost(string, repeated, tag = "3")]
    pub pub_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// participant consensus pub key
    #[prost(string, tag = "4")]
    pub consensus_pubkey: ::prost::alloc::string::String,
    /// hex encoded participant signature
    #[prost(string, tag = "5")]
    pub signature: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgCompleteDkg {
    const NAME: &'static str = "MsgCompleteDKG";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// MsgCompleteDKGResponse defines the Msg/CompleteDKG response type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCompleteDkgResponse {}
impl ::prost::Name for MsgCompleteDkgResponse {
    const NAME: &'static str = "MsgCompleteDKGResponse";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// MsgSubmitSignatures defines the Msg/SubmitSignatures request type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSubmitSignatures {
    #[prost(string, tag = "1")]
    pub sender: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub id: u64,
    #[prost(string, repeated, tag = "3")]
    pub signatures: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for MsgSubmitSignatures {
    const NAME: &'static str = "MsgSubmitSignatures";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// MsgSubmitSignaturesResponse defines the Msg/SubmitSignatures response type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSubmitSignaturesResponse {}
impl ::prost::Name for MsgSubmitSignaturesResponse {
    const NAME: &'static str = "MsgSubmitSignaturesResponse";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// MsgRefresh defines the Msg/Refresh request type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRefresh {
    /// authority is the address that controls the module (defaults to x/gov unless overwritten).
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// list of DKGs corresponding to key shares to be refreshed
    #[prost(uint64, repeated, tag = "2")]
    pub dkg_ids: ::prost::alloc::vec::Vec<u64>,
    /// removed participant set
    #[prost(string, repeated, tag = "3")]
    pub removed_participants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// new threshold set corresponding to the DKGs
    #[prost(uint32, repeated, tag = "4")]
    pub thresholds: ::prost::alloc::vec::Vec<u32>,
    /// timeout duration per DKG refreshing
    #[prost(message, optional, tag = "5")]
    pub timeout_duration: ::core::option::Option<::tendermint_proto::google::protobuf::Duration>,
}
impl ::prost::Name for MsgRefresh {
    const NAME: &'static str = "MsgRefresh";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// MsgRefreshResponse defines the Msg/Refresh response type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRefreshResponse {}
impl ::prost::Name for MsgRefreshResponse {
    const NAME: &'static str = "MsgRefreshResponse";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// MsgCompleteRefreshing defines the Msg/CompleteRefreshing request type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCompleteRefreshing {
    /// sender
    #[prost(string, tag = "1")]
    pub sender: ::prost::alloc::string::String,
    /// request id
    #[prost(uint64, tag = "2")]
    pub id: u64,
    /// participant consensus pub key
    #[prost(string, tag = "3")]
    pub consensus_pubkey: ::prost::alloc::string::String,
    /// hex encoded participant signature
    #[prost(string, tag = "4")]
    pub signature: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgCompleteRefreshing {
    const NAME: &'static str = "MsgCompleteRefreshing";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// MsgCompleteRefreshingResponse defines the Msg/CompleteRefreshing response type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCompleteRefreshingResponse {}
impl ::prost::Name for MsgCompleteRefreshingResponse {
    const NAME: &'static str = "MsgCompleteRefreshingResponse";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// MsgUpdateParams is the Msg/UpdateParams request type.
///
/// Since: cosmos-sdk 0.47
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateParams {
    /// authority is the address that controls the module (defaults to x/gov unless overwritten).
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// params defines the x/tss parameters to be updated.
    ///
    /// NOTE: All parameters must be supplied.
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for MsgUpdateParams {
    const NAME: &'static str = "MsgUpdateParams";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
/// MsgUpdateParamsResponse defines the Msg/UpdateParams response type.
///
/// Since: cosmos-sdk 0.47
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateParamsResponse {}
impl ::prost::Name for MsgUpdateParamsResponse {
    const NAME: &'static str = "MsgUpdateParamsResponse";
    const PACKAGE: &'static str = "side.tss";
    fn full_name() -> ::prost::alloc::string::String {
        ::prost::alloc::format!("side.tss.{}", Self::NAME)
    }
}
include!("side.tss.serde.rs");
include!("side.tss.tonic.rs");
// @@protoc_insertion_point(module)
